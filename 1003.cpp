#include<stdio.h>
//动态规划法    ( dp)
//http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html
int main()
{
    int T,m;
    m=0;
    while(~scanf("%d",&T))
    {
        while(T--)
        {
            int m,n,i,max,x,y,a[100000],start,end,dp[100000];
            scanf("%d",&n);
            start=end=x=y=0;
            max=-100000;
            for(i=0; i<n; ++i)
                scanf("%d",&a[i]);
            dp[0]=a[0];
            for(i=0; i<n; ++i)
            {
                if(dp[i-1]+a[i]>=a[i])
                {
                    dp[i]=dp[i-1]+a[i];
                    end=i;
                }
                else
                {
                    dp[i]=a[i];
                    start=i;
                    end=i;
                }
                if(max<dp[i])
                {
                    max=dp[i];
                    x=start;
                    y=end;
                }
            }
            printf("Case %d:\n",++m);
            printf("%d %d %d\n",max,x+1,y+1);
            //else
            //  printf("Case %d:\n%d %d %d\n\n",m,max,start+1,end+1);
            if(T != 0)
                printf("\n");
        }

    }
    return 0;
}
/*阶段决策过程（multistep decision process）是指这样一类特殊的活动过程，过程可以按时间顺序分解成若干个相互联系的阶段，
在每一个阶段都需要做出决策，全部过程的决策是一个决策序列。
动态规划（dynamic programming）算法是解决多阶段决策过程最优化问题的一种常用方法，难度比较大，
技巧性也很强。利用动态规划算法，可以优雅而高效地解决很多贪婪算法或分治算法不能解决的问题。
动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，
只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。
动态规划算法将问题的解决方案视为一系列决策的结果，与贪婪算法不同的是，在贪婪算法中，每采用一次贪婪准则，
便做出一个不可撤回的决策；而在动态规划算法中，还要考察每个最优决策序列中是否包含一个最优决策子序列，即问题是否具有最优子结构性质。

动态规划算法的有效性依赖于待求解问题本身具有的两个重要性质：最优子结构性质和子问题重叠性质。

1、最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。
最优子结构性质为动态规划算法解决问题提供了重要线索。

2、子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，
有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的解题效率。

当我们已经确定待解决的问题需要用动态规划算法求解时，通常可以按照以下步骤设计动态规划算法：

1、分析问题的最优解，找出最优解的性质，并刻画其结构特征；

2、递归地定义最优值；

3、采用自底向上的方式计算问题的最优值；

4、根据计算最优值时得到的信息，构造最优解。

1～3步是动态规划算法解决问题的基本步骤，在只需要计算最优值的问题中，完成这三个基本步骤就可以了。如果问题需要构造最优解，
还要执行第4步；此时，在第3步通常需要记录更多的信息，以便在步骤4中，有足够的信息快速地构造出最优解。

下面通过对具体实例的分析，帮助大家领会可用动态规划算法求解的问题应具有的两个性质以及动态规划算法的设计思想。

例：拦截导弹（问题来源：1999年全国青少年信息学（计算机）奥林匹克分区联赛高中组复赛试题第一题）

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，
但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000 的正整数），计算这套系统最多能拦截多少导弹，并依次输出被拦截的导弹飞来时候的高度。

样例：

INPUT

389 207 155 300 299 170 158 65

OUTPUT

6（最多能拦截的导弹数）

389 300 299 170 158 65

分析：因为只有一套导弹拦截系统，并且这套系统除了第一发炮弹能到达任意高度外，以后的每一发炮弹都不能高于前一发炮弹的高度；
所以，被拦截的导弹应该按飞来的高度组成一个非递增序列。题目要求我们计算这套系统最多能拦截的导弹数，并依次输出被拦截导弹的高度，实际上就是要求我们在导弹依次飞来的高度序列中寻找一个最长非递增子序列。

设X={x1,x2,…,xn}为依次飞来的导弹序列，Y={y1,y2,…,yk}为问题的最优解（即X的最长非递增子序列），
s为问题的状态（表示导弹拦截系统当前发送炮弹能够到达的最大高度，初值为s=∞——第一发炮弹能够到达任意的高度）。如果y1= x1，即飞来的第一枚导弹被成功拦截。那么，根据题意“每一发炮弹都不能高于前一发的高度”，问题的状态将由s=∞变成s≤x1（x1为第一枚导弹的高度）；在当前状态下，序列Y1={y2,…,yk}也应该是序列X1={x2,…,xn}的最长非递增子序列（大家用反证法很容易证明）。也就是说，在当前状态s≤x1下，问题的最优解Y所包含的子问题（序列X1）的解（序列Y1）也是最优的。这就是拦截导弹问题的最优子结构性质。

设D(i) 为第i枚导弹被拦截之后，这套系统最多还能拦截的导弹数（包含被拦截的第i枚）。
我们可以设想，当系统拦截了第k枚导弹xk，而xk又是序列X={x1, x2,…,xn}中的最小值，即第k枚导弹为所有飞来的导弹中高度最低的，则有D(k)=1；
当系统拦截了最后一枚导弹xn，那么，系统最多也只能拦截这一枚导弹了，即D(n)=1；其它情况下，也应该有D(i)≥1。根据以上分析，可归纳出问题的动态规划递归方程为：


假设系统最多能拦截的导弹数为dmax（即问题的最优值），则

dmax   （i为被系统拦截的第一枚导弹的顺序号）　

所以，要计算问题的最优值dmax，需要分别计算出D(1)、D(2)、……D(n)的值，然后将它们进行比较，找出其中的最大值。
根据上面分析出来的递归方程，我们完全可以设计一个递归函数，采用自顶向下的方法计算D(i)的值。然后，对i从1到n分别调用这个递归函数，就可以计算出D(1)、D (2)、……D(n)。
这样将会有大量的子问题被重复计算。比如在调用递归函数计算D(1)的时候，可能需要先计算D(5)的值；之后在分别调用递归函数计算D(2)、D(3)、D(4)的时候，
都有可能需要先计算D(5)的值。如此一来，在整个问题的求解过程中，D(5)可能会被重复计算很多次，从而造成了冗余，降低了程序的效率。

其实，通过以上分析，我们已经知道：D(n)=1。如果将n作为阶段对问题进行划分，根据问题的动态规划递归方程，
我们可以采用自底向上的方法依次计算出D(n-1)、D(n-2)、……D(1)的值。这样，每个D(i)的值只计算一次，并在计算的同时把计算结果保存下来，
从而避免了有些子问题被重复计算的情况发生，提高了程序的效率。算法代码如下：

for i=1 to n

D(i)=1

next i

for i=n-1 to 1 step -1

for j=i+1 to n

    if x(j)<=x(i) and D(i)<D(j)+1 then

D(i)=D(j)+1

endif

next j

next i

dmax=0:xh=1

rem dmax用来保存问题的最优值（系统最多能拦截的导弹数）；xh用来保存第一枚被拦截的导弹的顺序号，以便后面构造最优解

for i=1 to n

if D(i)>dmax then

    dmax=D(i)

    xh=i

endif

next i

我们在计算最优值时保存了被拦截的第一枚导弹的顺序号xh。接下来通过这个信息构造问题的最优解（由所有被拦截的导弹的高度组成的非递增序列）。算法代码如下：

print x(xh)

for i=xh+1 to n

if x(i)<=x(i-1) then

    print x(i)

endif

next i


结束语：动态规划算法和贪婪算法都是构造最优解的常用方法。动态规划算法没有一个固定的解题模式，技巧性很强。
可以说，动态规划算法在实际生活中的每一次应用都是一种创造。大家要多练习，多实践，从实践中领会动态规划算法的精髓，不断提高自己的应用能力*/
