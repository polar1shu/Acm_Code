#include<stdio.h>
int main()
{
    long long n,sum;
    while(~scanf("%lld",&n))
    {
        if(n<3)
            sum=n;
        else if(n%2 != 0)
            sum=n*(n-1)*(n-2);
        else
        {
            sum=n*(n-1)*(n-3);
            if(n%3 == 0)
                sum=(n-1)*(n-2)*(n-3);
        }
        printf("%lld\n",sum);
    }
    return 0;
}
/*最大的最小公倍数
 描述：对于一个整数n(1<=n<=10^6),取三个不小于n的正整数，使其最小公倍数最大。
 
 先介绍三条数论的基本知识：
 1.任意大于１的两个相邻的正整数是互质的。
 2.两个数的公约数只有１和－１，称为互质整数。
 3.两个数的公约数只有１，称为互质自然数。
 
 分析：最先想到的答案是n*(n-1)*(n-2),(注：n>2),但是我们得考虑是的,n和(n-2)差２，是否也互质？
 情况一：当ｎ为奇数时，我们考虑它二者是否有公约数２，显然没有，即结果为n*(n-1)*(n-2).
 情况二：当ｎ为偶数时，我们可以知道,它两者有公约数２，此时，我们在考虑n*(n-1)*(n-3),
 现在，(n-1)和(n-3)都是奇数，是互质，那我们就只要考虑n和(n-3)是否存在公约数　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　	了，即ｎ是否能被３整除；若ｎ不能被３整除，则就是结果了，否则，我们考虑n*(n-1)*(n-4),可以看到,n和(n-4)又都是偶数了...那我们再考虑n*(n-1)*(n-5),我们一直都在看n*(..)*(...)，忘记了(n-1)*(n-2)*(n-3)了没,我们来计算一下：
 n*(n-1)*(n-5)=n^3-6*n^2+5*n (1)
 (n-1)*(n-2)*(n-3)=n^3-6*n^2+11*n-6 (2)
 (2)-(1):6*n-6>=0
 即，如果（１）式可以的话，那（２）肯定要大于等于（１），所以，在这种情况下，（２）式是答案。
 */
